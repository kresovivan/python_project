#1.Списки List#
from msilib import change_sequence

#Инициализация списка переменными
my_list1=['one','two']
my_list2 = list(['one','two'])
#Добавление в список осуществляется через вызов у него метода append(val), где vak -добавляемое в окнец
#списка значение
my_list = list(['one','two'])
print(my_list)
my_list.append('three')
my_list.append('4')
my_list.append('5')
print(my_list)

my_new_list: list[int] = [4,5]
my_new_list.append(1043)
print(my_new_list)

#Добавление объекта в список на указанную позицию.
names = ['Max','Tom','Alex']
print(names)
names.insert(0,'John')
names.insert(0,'Ivan')
print(names)

#Удаление элемента из списка
names.remove('Ivan')
print(names)

#Сортировка списка
names.sort()
print(names)

#Посчитать сколько раз по значению повторяется элемент
my_list=[1,2,3,2,2,2,5,5,]
print(my_list.count(5))

#Присваивание списка новой переменной (копирование самого списка не выполняется)
my_array = [1,2,3,5,7,8,10]
print(my_array)
my_new_array = my_array
my_new_array.append(12)
print(my_array)

#Работа с копией существующего списка через новую переменную во избежание изменений исходного списка
#необходимо использовать метод copy()

my_array = [2,3,5,7,8,10]
print(my_array)
my_new_array = my_array.copy()
my_new_array.append(200)
print(my_array)
print(my_new_array)


# проверить, содержится ли в последовательности (списке, строке и т.д.) объект с
# определенным значением, можно следующим способом
my_array = [2,3,4,5,8,10]
print(2 in my_array)
print(0 in my_array)

#2.Множества set#
#Добавления элементов#
my_list = [0,1,1,2,3,9,4,5,6,6,7,8,9]
my_set = set() #пустое множество
my_set = set(my_list)
my_set = {0,1,1,2,3,9,4,5,6,6,7,8,100}
print(my_set)

#Изменение множества#
my_set.add(102)
print(my_set)
my_set.update([2,100,99,4,5,6,2030])
print(my_set)

#Удаление элементов#
my_set.remove(2)
print(my_set)
my_set.discard(100)
print(my_set)

#Операции над множествами
A = {0,1,2,3,4}
B = {1,3,5,6,7}
#Объединение
new_set = A | B
print(new_set)
#Пересечение
new_set = A & B
print(new_set)
#симметрическая разность
new_set = A ^ B
print(new_set)
#разность A - B
new_set = B - A
print(new_set)

#Проверка на то является ли множество A подмножеством B и наоборот выполняется следующим образом
A = {1,2,3}
B = {1,2,3,4}
#A является подмножеством B#
print(A.issubset(B))
#B является надмножеством A#
print(B.issuperset(A))
A.add(5)
print(A)

#3.Словари dictionary, неупорядоченные коллекции#

my_dict = { } #Пустой словарь
my_dict = {'name': 'Alex', 'course': 3}
#Вложение
my_dict = {'info': {'name':'Alex', 'course': 3}}
print('info' in my_dict)

#вывести все ключи
print(list(my_dict.keys()))
#вывести все значения
print(list(my_dict.values()))
#вывести коретжи пар ключ:значение
print(list(my_dict.items()))
#копировать словарь можно следующим образом
my_dict = {'name': 'Alex', 'course': 3}
my_new_dict = my_dict.copy()
my_new_dict.update({'info': 'None'})
print(my_dict)
print(my_new_dict)
my_dict = {'name':'Alex', 'course': 3, 'info':{'age':21,'country': 'rus'}}
print(my_dict)
my_new_dict = my_dict.copy()
my_new_dict['info']['age'] = 1
print(my_dict) #Изменились значения в исходном словаре, чтобы такого не было нужно использовать#
# глубокое копирование#

import copy
my_dict = {'name':'Alex', 'course': 3, 'info':{'age':21,'country': 'rus'}}
my_new_dict = copy.deepcopy(my_dict)
my_new_dict['info']['age'] = 1
print(my_new_dict)
print(my_dict) #первоисточник не изменился

#Условный оператор if#
t = 29
if t >= 30:
    print('Надеть шорты')
else:
    print('Надеть брюки')

#Вложенный if
value = 9
if value > 30:
    if value < 50:
        print('30 < value < 50')
    else:
        print('30 < value >=50')
else:
    if value > 10:
        print('30 >= value > 10')
    else:
        print('30 >= value < 10')
#Когда необходимо указать, что в блоке if ничего не выполняется, используется команда pass

a = 20
if a < 25:
    pass
else:
    a = 25
print(a)

A=50
Z=20
B=20
C=20
#Тернарный оператор
if A:
    Z=B
else:
    Z=C
#это можно представить ввиде:
Z=B if A else C
a = 300
b = 20
max_value = a if a > b else b
print(max_value)


value = 2
match value:
    case 2:
        print('2')
        print(f'{value} + 2 = {value + 2}')
    case 4:
        print('4')
    case _:
        print('8')


#Циклы и while и операторы break, continue, pass
#from multiprocessing import Pool
#from multiprocessing import Pool
##
# def process_range(start, end):
#     """Функция для обработки диапазона чисел."""
#     result = []
#     for x in range(start, end):
#         result.append(x)  # Вместо вывода на экран сохраняем числа в список
#     return result
#
# if __name__ == "__main__":
#     y = 9000  # Конечное число
#     num_processes = 30  # Количество процессов
#     chunk_size = y // num_processes  # Размер диапазона для каждого процесса
#
#     # Создаем список диапазонов для каждого процесса
#     ranges = [(i * chunk_size, (i + 1) * chunk_size) for i in range(num_processes)]
#     ranges[-1] = (ranges[-1][0], y)  # Убедимся, что последний диапазон включает остаток
#
#     # Используем Pool для параллельной обработки
#     with Pool(processes=num_processes) as pool:
#         results = pool.starmap(process_range, ranges)
#
#     # Объединяем результаты (если нужно)
#     final_result = []
#     for result in results:
#         final_result.extend(result)

##    print("Обработка завершена")##

x=0
y=5
while x < y:
    print(x, end=' ')
    x +=1
else:
    print('Happy End!')


#Оператор continue, позволяет пропускать оставшуюся часть, которую не нужно проверять и переводить программу в начало цикла

import time
start_time = time.time()  # Засекаем начальное время

x = 0

while x < 800:
    x += 1
    if x % 2 == 0:  # Проверяем, является ли число четным
        continue  # Пропускаем оставшуюся часть цикла для четных чисел
    print(f"Нечетное число: {x}")

end_time = time.time()  # Засекаем конечное время
execution_time = end_time - start_time  # Вычисляем время выполнения
print(f"Код выполнился за {execution_time:.4f} секунд")

#Оператор Break
#Он используется для немедленного выхода из цикла

x = 0

while x < 60000000:
    x += 1
    if x == 50000:
        print("Достигнуто число 5. Выход из цикла.")
        break  # Прерываем цикл
    print(f"Текущее число: {x}")
print("Цикл завершён.")


#Цикл for

for it in('first', 'second', 4, 5.9, 'finish'):
    print(it)

my_tuple_list = [(3,6), (0,1), (4,5), ('O',3.9)]
for (a,b) in my_tuple_list:
    print(a,b, end=' ')

#Списковые включения

my_list = [1.25, -9,10,3.78,-5.92, -1.16, 80]
new_list = [i if i > 0 else -1000 for i in my_list]
print(new_list)


#Передача объектов в функцию

def test(a,b,c):
    print('a = {}; b = {}; c = {}'.format(a,b,c))

x,y,z = (5, [1,4], 'Str')
test(x,y,z)
print('x = {}; y = {}; z = {}'.format(x,y,z))

#Проверим, что в качестве аргументов функции, в случае ее вызова, аргументам присваиваются ссылки
#на объекты из вызывающей области
def test(a,b,c):
    print('a = {}; b = {}; c = {}'.format(id(a),id(b),id(c)))

x,y,z = (5, [1,4], 'Str')
test(x,y,z)
print('x = {}; y = {}; z = {}'.format(id(x),id(y),id(z)))

#Попробуем изменить значение объектов в функции и посмотреть, что из этого получится
def test(a,b,c):
    a = 2
    b[0] = 'Oo'
    c = '^_^'
    print('a = {}, b = {}, c = {}'.format(a,b,c))
    print('a = {}, b = {}, c = {}'.format(id(a), id(b), id(c)))

x,y,z = (5, [2,1,4], 'Str')
test(x,y,z)
print('x = {}, y={}, z={}'.format(x,y,z))
print('x = {}, y={}, z={}'.format(id(x),id(y),id(z)))
#В случае присваивания нового значения переменной, которая хранит ссылку
# на объект неизменяемого типа, создается новый объект, на который теперь и будет ссылаться данная переменная
# (аhгументы a и c),
#а при изменении значения объекта изменяемого типа новый объект создаваться не будет (аргумент b)


#Значения аргументов по умолчанию
def test_default(a=10):
    print(a)
test_default('Hi!')
test_default() #10

def test_default2(a=10, b=12):
    print(a+b)
test_default2()
test_default2(4)
test_default2(4,2)

#Если первыми аргументами поставить необязательные
# (значения которых заданы по умолчанию), а следом за ними обязательные аргументы, то
#интерпретатор Python сообщит об ошибке SyntaxError: parameter without a default follows parameter with a default

# def test_default3(b=12,a):
#     print(a+b)
# test_default3(4,2)

#Режимы сопоставления аргументов функций. Python предлагает дополнительные инструменты, которые позволяют
#функции принимать необязательные аргументы, благоджаря чему можно создавать гибкие API в модулях и классах.
#1.Позиционная передача аргументов (сопоставляется слева направо) при таком подходе выполняется сопоставление переданных
#значений аргументов с именами аргументов в заголовке функции по позиции слева направо

def custom_function(a,b,c):
    print (a+b+c)
custom_function(10,4,8)

#2.Передача по имени аргумента (сопоставляются по имени аргумента, имя=значение)
def custom_function1(a,b,c=2):
    print(a + b + c)
custom_function1(b=2, c=1, a=4)

#3.Переменное количество позиционных аргументов (сначала сопоставляются единичные позиционные элементы,
#потом итерируемый список позиционных элементов, а далее аргументы сопоставляются по имени

def custom_function3(a,b,c,*args):
    print(a + b + c + sum(*args))

custom_function3(1,1,1,[10,20,30])

#4.Передача произвольного количества позиционных и ключевых элементов.
# * (одна звёздочка):
#Используется для работы с позиционными аргументами.
#Все переданные позиционные аргументы собираются в кортеж (tuple).
# ** (две звёздочки):
#Используется для работы с именованными аргументами.
#Все переданные именованные аргументы собираются в словарь (dictionary).

def custom_function4(*args, **kwargs): # *args, **kwargs можно заменить на *a и **b например
    if args:
        print(args)
        if kwargs:
            print(kwargs)
custom_function4(10,20, key='Hi', Oo = 100)

#5.Передача произвольного числа ключевых параметров

def custom_function5(**kwargs):
    print(kwargs)
custom_function5(key='Hi', Oo=100)

#Возвращение результатов выполнения функцией
#В случае передачи в качестве аргумента функции переменной изменяемого типа необъодимо быть осторожным и не менять значение
#аргумента без необходимости
#Функции, которые изменяют свои аргументы, сложнее тестировать и отлаживать, так как они имеют побочные эффекты.
#Изменяемые объекты передаются в функции по ссылке, поэтому их изменение внутри функции влияет на оригинальный объект.
#Чтобы избежать неожиданных изменений, создавайте копии объектов или используйте неизменяемые типы.
#Если изменение аргумента является частью логики функции, это должно быть явно задокументировано.
#Для возвращения результатов работы функции в вызывающий ее код используется оператор return
#При его отсутствии в теде функции по умолчанию возвращается None

def test_return1(a,b):
    c = a + b
print(test_return1(2,4)) #Возвращает none

def test_return2(a,b):
    return a + b
print(test_return2(2,4)) #возвращает 6

#Бывают случаи, когда нужно вернуть не одно, а несколько значений. Здесь на помощь приходят кортежи

def test_return3(a,b):
    c = a + b
    m = a * b
    e = a ** b
    d = a / b
    s = a - b
    return c, m, e, d, s

print(test_return3(4,2))

# Чтобы присвоить значения из возвращаемого
# функцией кортежа переменным, можно применить следующие
# методы распаковки последовательностей

x, y, q, w, z = test_return3(4,2)
print(x, y, q, w, z) # будет отображаться как 8 16 2.0 2 вместо (6, 8, 16, 2.0, 2)
_, *my_list, _ = test_return3(4,2) #Первое и последнее значение игнорируются, а
# остальные значения (8, 16, 2.0) собираются в список с помощью *my_list.
print(my_list)
y, *my_list, q = test_return3(4,2)
print(y,my_list, q)

#Итог: Локальные переменные: Видны только внутри функции.Удаляются после завершения функции.
#Глобальные переменные:Видны везде в программе. Для изменения внутри функции используйте global.
#Переменные из внешней функции:Видны во вложенных функциях. Для изменения используйте nonlocal.
#Встроенные переменные: Это функции и объекты Python, доступные всегда.#

#1. Локальная область видимости (Local scope)
def my_function1():
    x = 10  # Локальная переменная
    print("Внутри функции:", x)

my_function1()
# print("Снаружи функции:", x)  # Ошибка! Переменная x не определена

#2.Область видимости вложенной функции (Enclosing scope)
#Если функция определена внутри другой функции, то внутренняя функция имеет доступ к переменным внешней функции.
def outer_function():
    y = 20  # Переменная внешней функции

    def inner_function():
        print("Внутри вложенной функции:", y)  # Доступ к y из внешней функции
    inner_function()
outer_function()

#3.3. Глобальная область видимости (Global scope)
#Переменные, объявленные вне всех функций, являются глобальными. Они доступны в любом месте программы.
z = 30  # Глобальная переменная

def my_function():
    print("Внутри функции:", z)  # Доступ к глобальной переменной

my_function()
print("Снаружи функции:", z)  # Доступ к глобальной переменной

#Замыкания
#Замыкание (closure) — это функция, которая "запоминает" окружение, в котором она была создана.
# Это окружение включает все переменные, которые были доступны на момент создания функции,
# даже если они больше не существуют в текущей области видимости.
# Проще говоря, замыкание — это функция, которая:
# Определена внутри другой функции.
# Использует переменные из внешней функции.
# Возвращается как результат работы внешней функции.
#Когда вы создаёте замыкание, Python "запоминает" значения переменных из внешней функции,
# даже после того, как выполнение внешней функции завершилось. Это позволяет использовать
# эти переменные позже, когда замыкание будет вызвано.

def create_counter():
    count = 0  # Переменная count "запоминается" замыканием

    def counter():
        nonlocal count  # Указываем, что count — из внешней функции
        count += 1
        return count

    return counter  # Возвращаем замыкание

my_counter = create_counter()
print(my_counter())  # Вывод: 1
print(my_counter())  # Вывод: 2
print(my_counter())  # Вывод: 3
print(my_counter())  # Вывод: 4
print(my_counter())  # Вывод: 5
print(my_counter())  # Вывод: 6

#Лямбда-функции в Python — это анонимные (безымянные) функции, которые создаются с помощью ключевого слова lambda.
# Они полезны в ситуациях, когда нужно быстро определить небольшую функцию на лету, без необходимости объявлять
# её с помощью def.
#Зачем нужны лямбда-функции?
#Краткость:
# Лямбда-функции позволяют записать простую функцию в одну строку, что делает код более компактным и читаемым.
# Удобство для простых операций:
# Они идеально подходят для простых операций, которые не требуют сложной логики.
# Использование в функциях высшего порядка:
# Лямбда-функции часто используются вместе с функциями высшего порядка, такими как map(), filter(), sorted()
# и другими, где нужно передать функцию как аргумент.

# Обычная функция
def add(x, y):
    return x + y

# Лямбда-функция
add_lambda = lambda x, y: x + y

print(add(20, 30))        # Вывод: 5
print(add_lambda(20, 30)) # Вывод: 5


#Пример 2: Использование лямбда-функции с map()
#Функция map() применяет другую функцию к каждому элементу последовательности. Лямбда-функции часто используются для этой цели.
numbers = [1, 2, 3, 4, 5]
# Умножаем каждый элемент на 2
doubled = map(lambda x: x * 2, numbers)
print(list(doubled))  # Вывод: [2, 4, 6, 8, 10]

#Пример 4: Использование лямбда-функции с sorted()
#Функция sorted() сортирует последовательность.
#Лямбда-функции могут использоваться для указания ключа сортировки.
students = [
    {"name": "Alice", "age": 25},
    {"name": "Bob", "age": 20},
    {"name": "Charlie", "age": 22},
]

# Сортируем по возрасту
sorted_students = sorted(students, key=lambda student: student["age"])
print(sorted_students)
#Когда использовать лямбда-функции?
#Для простых операций, которые можно записать в одну строку.
#В функциях высшего порядка, таких как map(), filter(), sorted().
#Когда функция используется только один раз и не требует сложной логики.

#Рекурсивная функция — это функция, которая вызывает саму себя. То есть внутри функции есть вызов этой же функции.
#Это похоже на матрёшку: каждая функция "раскрывается" и вызывает себя снова, пока не достигнет определённого условия.
total = 0
for i in range(1, 20):
    total += i
print(total)  # Вывод: 190


def sum_numbers(n):
    if n == 1:  # Базовый случай: если n равно 1, возвращаем 1
        return 1
    else:
        return n + sum_numbers(n - 1)  # Рекурсивный случай: вызываем функцию снова

print(sum_numbers(19))  # Вывод: 190

#Косвенная рекурсивная функция:
#Как работает косвенная рекурсия?
#Косвенная рекурсия возникает, когда две или более функций вызывают друг друга,
# создавая цикл вызовов. Это может быть полезно в задачах, где логику удобно разделить на несколько функций.
#Осторожно: Глубина рекурсии
#Как и с обычной рекурсией, косвенная рекурсия может привести к ошибке, если глубина вызовов слишком большая.
# В Python есть ограничение на глубину рекурсии (обычно около 1000 вызовов).
# Если его превысить, программа завершится с ошибкой RecursionError.

def jump(n):
    if n == 0:
        return
    print("Прыжок!")
    run(n - 1)  # Вызываем другую функцию

def run(n):
    if n == 0:
        return
    print("Бег!")
    jump(n - 1)  # Вызываем первую функцию

jump(3)

#Декорирование функций
#Декораторы в Python позволяют расширять и изменять поведение вызываемых объектов (функций, методовб и классов)
#без необходимой модификации самих вызываемых объектов. Поэтому любая достаточно универсальная функциональность, которую
#можно присоединить к разрабатываемому классу или функции, является отличным кандидатом для декорирования:
#ведение протокола операций
#контроль за доступому и утентификацией,
#кэширование
#ограничение частоты вызова API
#Как работают декораторы?
#Декоратор — это функция, которая принимает другую функцию в качестве аргумента, добавляет
#к ней новое поведение и возвращает изменённую функцию.
import time

# Декоратор для замера времени выполнения
def measure_time(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()  # Запоминаем время начала
        result = func(*args, **kwargs)  # Вызываем исходную функцию
        end_time = time.time()  # Запоминаем время окончания
        print(f"Функция {func.__name__} выполнилась за {end_time - start_time:.4f} секунд")
        return result
    return wrapper

# Применяем декоратор к функции
@measure_time
def some_function():
    time.sleep(1)  # Имитация долгой работы
    print("Функция выполнена")

some_function()

#Декоратор для логирования
def log_function_call(func):
    def wrapper(*args, **kwargs):
        print(f"Вызов функции {func.__name__} с аргументами: {args}, {kwargs}")
        result = func(*args, **kwargs)
        print(f"Функция {func.__name__} завершилась с результатом: {result}")
        return result
    return wrapper

@log_function_call
def add(a, b):
    return a + b

add(3, 5)

#Декоратор для обработки исключений
def handle_exceptions(func):
    def wrapper(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except Exception as e:
            print(f"Произошла ошибка: {e}")
    return wrapper

@handle_exceptions
def divide(a, b):
    return a / b

divide(10, 0)  # Вывод: Произошла ошибка: division by zero

#Генераторные функции:
#Генераторные функции в Python — это специальные функции, которые позволяют создавать итераторы с помощью
#ключевого слова yield. В отличие от обычных функций, которые возвращают результат и завершают выполнение,
#генераторные функции могут приостанавливать своё выполнение и возвращать промежуточные значения по мере
#необходимости. Это делает их мощным инструментом для работы с последовательностями, особенно когда данные
#Как работает генератор:При вызове генераторной функции она не выполняется сразу, а возвращает объект-генератор.
# При каждом вызове next() выполнение функции продолжается с того места, где она была приостановлена
# (после последнего yield), до следующего yield.
# Когда функция завершает выполнение (или встречает return), вызывается исключение StopIteration.

#Пример генерации нарастающей последовательности чисел от 0 до 3
def gen_test():
    N=0
    while N < 3:
        yield N
        N += 1

for x in gen_test():
    print(x, end=' ')

#Аналог генератора функции нарастающей последовательности, тело которой состоит только из yield

def gen_surprise_test():
    yield 0
    yield 1
    yield 2

for x in gen_surprise_test():
    print(x, end=' ')


#Генераторы можно использовать для фильтрации и преобразования данных на лету, например,
# при обработке данных из базы данных или API.

def filter_and_transform(data):
    for item in data:
        if item["age"] > 10:
            yield {
                "name": item["name"].upper(),
                "age": item["age"]
            }

# Использование
users = [
    {"name": "Alice", "age": 25},
    {"name": "Bob", "age": 17},
    {"name": "Charlie", "age": 30},
    {"name": "Robert", "age": 40},
    {"name": "Albert", "age": 50}
]

for user in filter_and_transform(users):
    print(user)


#Определение модуля
#Генераторы можно использовать для фильтрации и преобразования данных на лету, например, при
#обработке данных из базы данных или API.
#Зачем нужны модули?
# Организация кода
# Модули помогают разбивать большой проект на небольшие, логически связанные части.
# Упрощают навигацию по коду.
# Переиспользование кода:
#Модули можно импортировать в другие программы или модули, что позволяет избежать дублирования кода.
#Изоляция:
#Переменные и функции, определённые в модуле, не конфликтуют с другими частями программы, если они не импортированы явно.
#Сокрытие реализации:
#Модули позволяют скрыть детали реализации, предоставляя только необходимый интерфейс (например, через __all__).
#Упрощение тестирования:
#Модули можно тестировать независимо от основной программы.
#Преимущества модулей:
# Упрощение разработки:
# Код становится более читаемым и поддерживаемым.
# Повторное использование:
# Один модуль можно использовать в нескольких проектах.
# Модульность:
# Проект можно разбить на независимые компоненты.
# Управление зависимостями:
# Модули можно устанавливать и обновлять отдельно (например, через pip).
# Производительность:
# Модули кэшируются (файл .pyc), что ускоряет их повторное использование.


# math_operations.py

def add(a, b):
    return a + b

def subtract(a, b):
    return a - b

def multiply(a, b):
    return a * b

def divide(a, b):
    if b == 0:
        raise ValueError("Cannot divide by zero!")
    return a / b

# main.py

import math_operations as mo  # Импортируем модуль

result_add = mo.add(10, 5)
result_subtract = mo.subtract(10, 5)
result_multiply = mo.multiply(10, 5)
result_divide = mo.divide(10, 5)

print(f"Add: {result_add}")
print(f"Subtract: {result_subtract}")
print(f"Multiply: {result_multiply}")
print(f"Divide: {result_divide}")








