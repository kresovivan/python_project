"""Встроенные типы данных Python
Поскольку в Python все является объектом, то неудивительно, что в отличие от других
языков программирования, помимо пользовательских типов (классов) существуют такие
типы данных как функция, файл, модуль, метод, скомпилированный код.

К стандартным (встроенным) типам Python относят:
1. none
2. булевы значения
3. Числа (Numeric Type):
- int - целое число
- float - число с плавающей точкой
- complex - комплексное число
4.Списки (Sequence Type):
- list - список
- tuple - кортеж
- range - диапазон
5.Строки(Text Sequence Type):
- str
6.Бинарные списки (Binary Sequence Types):
- bytes - байты
- bytearray - массивы байтов
- memoryview - специальные объекты для доступа к внутренним данным объекта через protocol buffer
7.Множества (Set Types):
- set - множество
- frozenset неизменяемое множество;
8.Словари (Mapping Types):
- dict

Все типы данных в Python делятся на две категории изменяемые - mutable, неизменяемые - immutable.

К неизменяемым относят символьные строки, числа, булевы значения, неизменяемые множества и кортежи.
Остальные типы относятся к изменяемым.

+------+-------------------------+-----------------------+---------------------------------+
|  №   | Тип данных              | Изменяемость          | Пример                         |
+------+-------------------------+-----------------------+---------------------------------+
|  1   | None                    | ❌ Неизменяемый       | None                           |
|  2   | bool                    | ❌ Неизменяемый       | True, False                    |
| 3.1  | int                     | ❌ Неизменяемый       | 42, -5                         |
| 3.2  | float                   | ❌ Неизменяемый       | 3.14, -2.5                     |
| 3.3  | complex                 | ❌ Неизменяемый       | 1+2j                           |
| 4.1  | list                    | ✅ Изменяемый         | [1, 2, 3]                      |
| 4.2  | tuple                   | ❌ Неизменяемый       | (1, 2, 3)                      |
| 4.3  | range                   | ❌ Неизменяемый       | range(5)                       |
|  5   | str                     | ❌ Неизменяемый       | "hello"                        |
| 6.1  | bytes                   | ❌ Неизменяемый       | b'hello'                       |
| 6.2  | bytearray               | ✅ Изменяемый         | bytearray(b'hello')            |
| 6.3  | memoryview              | ⚠️ Зависит от объекта | memoryview(b'hello')           |
| 7.1  | set                     | ✅ Изменяемый         | {1, 2, 3}                      |
| 7.2  | frozenset               | ❌ Неизменяемый       | frozenset([1, 2, 3])           |
|  8   | dict                    | ✅ Изменяемый         | {'a': 1, 'b': 2}               |
+------+-------------------------+-----------------------+---------------------------------+


Разница между ними заключается в том, что в случае объявления имени переменной неизменяемого типа
ей задается идентификатор, который невозможно изменить.
"""


n = 10
b = n
print('id n=', id(n))
print('id b=', id(b))

"""
Реузльтат:
id n = 140724157064600
id b = 140724157064600

Два значения одинаковы
"""

"""
Если изменить значение n, то будет создан новый объект, с новым значением на который будет ссылаться
переменная n
id n = 140724157064440
id b = 140724157064600
"""
n = 5
print('id n=', id(n))
print('id b=', id(b))


"""В случае работы с изменяемыми типами данных не будет создаваться новый объект, а идентификатор
останется без изменений
id n= 2390250213312
id b= 2390250213312 """

n = [1,2]
b = n
print('id n=', id(n))
print('id b=', id(b))
print(b)
print(n)
"""
Изменяем данные
id n= 2439073681344
id b= 2439073681344
"""
b[0] = 5
n[1] = 4
print('id n=', id(n))
print('id b=', id(b))
print(b)
print(n)

"""Поскольку в Python динамический типизация, можно не указывать тип объявляемой переменной,
он выведется в процессе компиляции программы в байт-код, и далее будет выполняться проверка, чтобы
операции производились над объектами одного типа (сильная типизация)"""



"""Строки
применяется для хранения строковой информации и произвольных значений байтов.
Строки представляют собой последовательность из односимвольных строк и поддерживают
операции, которые предполагают наличие позиционного порядка среди элементов:
- индексация,
- срез,
- конкатенация,
- повторение.
"""


"""Индексация"""
my_str = 'Hello'
#my_str = " Test"
print(len(my_str)) #Длина строки = 5
print(my_str[0])   #H выводим первый элемент, та как индексация начинается с нуля

"""Срез"""
print(my_str[1:3]) #Срез el из Hello
print(my_str[:]) #Полный срез Hello
print(my_str[1:]) #Срез ello
print(my_str[0:3]) #Срез Hel
print(my_str[:-1]) #Срез Hell

print(my_str[::1]) #Срез от первого до последнего символа с шагом 1 - Hello
print(my_str[::2]) #Срез от первого до последнего символа с шагом 2 - Hlo
print(my_str[0:4:2]) #Срез от 0 до 3 элемента включительно с шагом 2 - Hl
print(my_str[::-1]) #Перевернуть последовательность olleH

"""Конкатенация"""
print(my_str + "!!!") #Конкатенация Hello!!!
print(my_str + '!!!') #Конкатенация Hello!!!
print(my_str * 3) #Повторение HelloHelloHello
print([1,7,9] + [8,5]) #Конкатенация [1, 7, 9, 8, 5]
print([1,2,3] * 3) #Повторение1, 2, 3, 1, 2, 3, 1, 2, 3]

"""Строки относятся к неизменяемому типу данных и их нельзя модифицировать, обращаясь по индексу
элемента"""

#my_str[1] = 'R' #'str' object does not support item assignment
my_str = "Hello"
# Хотим заменить 'e' на 'R' → "HRllo"
new_str = my_str[0] + 'R' + my_str[2:]
print(new_str)  # "HRllo"

"""Имеется возможность модифицировать текстовые данные на месте, для этого необходимо
 развернуть их в список индивидуальных символов и объединить вместе с пустым разделителем"""

my_str = 'Hello'
#Развернуть в список
my_list = list(my_str)
print(my_list) # ['H', 'e', 'l', 'l', 'o']
my_list[0] = 'S' #Изменить на месте
print(' / '.join(my_list)) #S / e / l / l / o
print(''.join(my_list)) #Sello

"""Методы, которые специфичны только для строкового типа данных и не распространяются
на последовательности
Данные методы возвращают измененную строку, но не модифицируют ту, над которой производится операция
К ним относят:
- find;
- replace;
- split;
- upper
- rstrip;
- lstrip
и другие ;
"""

my_str = 'Hello'
#Поиск смещения подстроки
print(my_str.find('o')) # 4
#Замена вхождения подстроки в mystr другой подстрокой
print(my_str.replace('el', 'RTY')) #HRTYlo
print(my_str) #Hello

line = 'ffff,ttt,nn,d'
#Разбить строку по разделителю ',' в список подстрок
print(line.split(',')) #['ffff', 'tttt', 'nn', 'd']
#Преобразовать символы строки в верхний регистр
print(my_str.upper()) #HELLO

line = 'ffff,ttt,nn,d\n'
#Удалить пробельные символы с правой стороны
print(line.rstrip()) #ffff,ttt,nn,d
#Методы можно чередовать
#Замена подстроки в строке с последующим ее разделением в список
print(line.replace('tt','RTY').split(',')) #['ffff,RTYt,nn,d\n']

"""Списки
позиционно упорядоченные коллекции объектов произвольных типов, не имеющие фиксированного размера
В отличие от строк списки можно модифицировать на месте путем присваивания по индексу или вызовом 
некоторых списковых методов
Это позволяет использовать списки как довльно гибкий инструмент для представления произвольных
коллекций таких как перечня продуктов в магазине, учащихся в школе и т.д.

К основным характеристикам списков можно отнести то, что они:
- являются упорядоченными коллекциями произвольных объектов;
- поддерживают доступ по смещению
- имеют переменную длину
- разнородны и допускают произвольно глубокое вложение
- относятся к категории "изменяемая последовательность"
- представляют собой массивы ссылок на объекты 
"""

my_list = []
my_list = list()

#Если список необходимо инициализировать переменными в момент его объявления, используют следующие конструкции
my_list1 = ['one', 'two']
my_list2 = list(['one', 'two'])

#Добавление в список осуществляется через вызов у него метода .append(val), где val - добавляемое значение в конец списка
print(my_list1) # ['one', 'two']
my_list1.append('three') # ['one', 'two', 'three']
print(my_list1)

"""Важно чтобы в списке обязательно содержались или в него добавлялись данные одного типа"""

my_list1.append(4)
my_list1.append(5)
print(my_list1) #['one', 'two', 'three', 4, 5]

my_new_list: list[int] = [4,5]
my_new_list.append('add')
print(my_new_list)

"""Ошибка будет возникать не на этапе компиляции а на этапе выполнения программы
Это связано с тем, что типы в Python определяются автоматически во время выполнения, а не
при объявлении их в коде
Получается, что разработчик никогда не определяет переменные заблаговременно, все сводится
к переменным, объектам, и связям между ними"""

"""
for it in my_new_list:
    it = it - 1
    print(it) #TypeError: unsupported operand type(s) for -: 'str' and 'int' 
"""

"""Чтобы проверить код на соответствие типов объектов необходимо установить
pip install mypy

(.venv) PS C:UsersKresov IvanPycharmProjectsPythonProject> mypy introduction_to_python_chernyshev.py
introduction_to_python_chernyshev.py:88: error: Incompatible types in assignment (expression has type "list[int]", variable has type "int")  [assignment]
introduction_to_python_chernyshev.py:99: error: Unsupported target for indexed assignment ("int")  [index]
introduction_to_python_chernyshev.py:100: error: Unsupported target for indexed assignment ("int")  [index]
introduction_to_python_chernyshev.py:231: error: Argument 1 to "append" of "list" has incompatible type "int"; expected "str"  [arg-type]
introduction_to_python_chernyshev.py:232: error: Argument 1 to "append" of "list" has incompatible type "int"; expected "str"  [arg-type]
introduction_to_python_chernyshev.py:236: error: Argument 1 to "append" of "list" has incompatible type "str"; expected "int"  [arg-type]
Found 6 errors in 1 file (checked 1 source file)
(.venv) PS C:UsersKresov IvanPycharmProjectsPythonProject>

"""

# Добавление объекта в список на указанную позицию, где все элементы индекса сдвигаются вправо
names = ["Max","Tom","Alex"]
print(names)
names.insert(1,"John")
print(names)

# Метод extend() добавляет все элементы другого списка в конец текущего списка
one = [1,2]
two = [3,4]
one.extend(two)
print(one)

del names[0]
print(names)

names.pop(0)
print(names)

names.remove('Alex')
print(names)


#Сортировка элементов списка осуществляется следующим образом
names = ["Max","Tom","Alex"]
names.sort()
print(names) #Необходимо помнить что при сортировке списка с разнотипными элементами может произойти ошибка

new_array = [2,'abc','ttt','10', 3.6]
#new_array.sort()
#print(new_array) #TypeError: '<' not supported between instances of 'str' and 'int'
new_array.sort(key=str) # передаем на вход метода sort параметр key
print(new_array)

#Необходимо посчитать, сколько раз по значению повторяется элемент в списке
my_list = [1,2,2,2,2,2,2,3,4,4,4,4,4]
my_list1 = ['Ivan','Ivan','Ivan', 'Petr','Ivan', 'Petr','Ivan','Ivan']
print(my_list.count(2))
print(my_list.count(4))
print(my_list1.count('Ivan'))

#Во избежание изменение изменений исходного списка необходимо использовать метод copy
my_array = [2,3,5,7,8,10]
my_new_array = my_array.copy()
my_new_array.append(12)
print(my_array)     #[2, 3, 5, 7, 8, 10]
print(my_new_array) #[2, 3, 5, 7, 8, 10, 12]

#Проверить содержится ли в (последовательности, списке, строке и т.д.) объект с определенным значением
my_array = [2,3,5,7,8,10]
print(2 in my_array) #True
print(0 in my_array) #False

"""Кортежи - изменяемые последовательности, при их создании необходимо использовать следующее правило, 
если в круглые скобки заключен один элемент, то Python рассматривает их как обычные, а если заключено
несколько элементов, разделенных запятыми, Python рассматривает их как кортежи
Кортежи можно создать с использованием синтаксиса литерала, заключив его компоненты в круглые скобки,
разделив их запятыми
Также для создания кортежа можно использовать класс tuple, которому для построения нового кортежа в
конструктор класса подается последовательность (список)

К основным характеристикам кортежей можно отнести то, что они:
- являются упорядоченными коллекциями произвольных объектов
- поддерживают доступ по смещению
имеют фиксированную дину, разнородны, допускают произвольно глубокое вложение
-представляют собой массивы ссылок на объекты
-относятся к категории неизменяемая последовательность
"""

my_tuple = ('Alex','John')
print(my_tuple)


my_tuple1 = tuple(['Alex','John'])
print(my_tuple1)

"""Кортежи как и рассмотрение ранее списки поддерживают ряд общих методов работы с ними
- индекс, индекс индекса, срез, дина
- конкатенация и повторение
- итерация
- членство
- подсчет
"""
# Если необходимо изменить значения объектов, находящихся в кортеже, применяют следующий подход.
# 1.На основе существующего кортежа создается список, содержащий в себе объекты, хранимые в кортеже
# 2.Далее производится работа со списком
# 3.На последнем шаге из данного списка создается новый кортеж
# 4.Ссылка на него присваивается переменной, через чье имя осуществляется работа с исходным кортежем

my_tuple = 2,3,4,5
print(my_tuple)
my_list = list(my_tuple)
print(my_list)
my_list = list(map(lambda x:x*2, my_list))
print(my_list)
my_tuple = tuple(my_list)
print(my_tuple)


my_tuple1 = 2,3,4,5
my_list1 = list(my_tuple1)
my_list1 = [x*2 for x in my_list1]
print(my_list1)
my_tuple1 = tuple(my_list1)
print(my_tuple1)

"""Можно использовать именованные кортежи"""
from collections import namedtuple
ItemRec = namedtuple('ItemRec',['name', 'age', 'jobs'])
my_tuple = ItemRec(name='Alex', age=24, jobs=['Python', 'Java'])
print(my_tuple)
print(my_tuple[0], my_tuple[2], my_tuple[1]) #Alex ['Python', 'Java'] 24


"""Именованный кортеж можно переименовать в словарь"""
my_dict = my_tuple._asdict()
print(my_dict['name'], my_dict['jobs'])
print(my_dict)


"""Множества
неупорядоченная совокупность объектов, в которой не может быть дубликатов
Оно может быть создано на базе списка или других последовательностей, элементы которых
можно перебирать. Однако, в отличие от списков и кортежей, для множеств неважен порядок
элементов
Он часто используется для двух целей: удаление дубликатов и для проверки принадлежности
Так как механизм поиска основан на оптимизированной функции хеширования, реализованной 
для словарей операция поиска занимает очень мало времени даже для очень больших множеств.

Объявить множество можно следующим способом
"""

my_list = [0,1,1,2,3,9,4,5,6,6,7,8,9]
print(my_list)
my_set = set() #пустое множество
my_set = set(my_list) # удалить дубликаты
print(my_set) #{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}

#Для добавления элементов используется следующие методы:
my_set.add(102)
print(my_set) #{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 102}
my_set.update([2,100,99,4,5,6])
print(my_set)  #{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 102, 100, 99} Повторяемые значения игнорируются при update

#Удаление элементов из множества производится следующим способом:
my_set.remove(2)
print(my_set) #{0, 1, 3, 4, 5, 6, 7, 8, 9, 102, 100, 99}

my_set.discard(100) #Если не будет удаляемого объекта, то не выведет ошибку в программе
print(my_set) #{0, 1, 3, 4, 5, 6, 7, 8, 9, 102, 99}

"""Операции над множествами
Пересчение
Симметричная разница
Разница
Объединение
"""

A = {0,1,1,2,3,9,4,5,6,6,7,8,9}
B = {1,3,6,10,15,21,28,36,45}
print(A)
print(B)

#Объединение
new_set_union = A.union(B)
print(new_set_union)

#Пересечение
new_set_intersect = A.intersection(B)
print(new_set_intersect)

#Cимметрическая разность
new_set_symmetric_difference = A.symmetric_difference(B)
print(new_set_symmetric_difference)


#Разность
new_set_difference = A.difference(B)
print(new_set_difference)

#При этом три из приведенных операций симметричны:
#Объединение
check = ( A | B) == (B | A) # True
#Пересечение
check1 = ( A & B) == (B & A) # True
#Cимметрическая разность
check2 = ( A ^ B) == (B ^ A) #True

print(check)
print(check1)
print(check2)

#Проверка на то, является ли множество A подмножеством B и наоборот, выполняется следующим способом:
A = {1,2,3}
B = {1,2,3,4}
#А является подмножеством B ?
print(A.issubset(B)) #True
#B является подмножеством A ?
print(B.issubset(A)) #False

# Является ли множество A надмножеством множества B.
"""Надмножество = содержит ВСЕ элементы другого множества (и возможно еще свои)
A.issuperset(B) возвращает True, если все элементы B есть в A
A.issuperset(B) возвращает False, если хотя бы один элемент из B отсутствует в A"""
print(A.issuperset(B)) #False

# Является ли множество B надмножеством множества A.
print(B.issuperset(A)) #True

"""Проверка на т входит ли элемент в множество, осуществляется посредством использования
оператора in (not in): """

B = {1,2,3,4}
print(0 in B)     #False
print(0 not in B) #True
print(1 not in B) #False
print(1 in B)     #True

"""Так как множества должны вычислять хеш-код для каждого элемента, то в них могут храниться только
хешируемые элементы
В языке Python изменяемые элементы не являются хешируемыми.
Это означает, что хешировать список или словарь невозможно.
А для хеширования пользовательских классов необходимо реализовывать методы
__hash__ и __eq__ .
"""


"""Словари
Словарь наиболее гибкий тип данных в Python
Если списки можно рассматривать как упорядоченные коллекции объектов, то словари это неупорядоченные
коллекции.
Их главное отличие от списка состоит в том, что в словарях элементы сохраняются и извлекаются по ключу, а не
по позиционному смещению.

Характеристики словарей:
- поддерживают доступ по ключу, а не по смещению
- являются неупорядоченными коллекциями произвольных объектов
- имеют переменную длину, разнородны и допускают произвольно глубокое вложение
- относятся к категории "изменямое отображение"
- представляют собой таблицы ссылок на объекты (хеш-таблицы)
В форме литерального выражения словарь записывается как ограниченная фигурными скобками серия пар: "ключ:значение",
разделенных запятыми.
Словари можно вкладывать в коллекции, записывая один словарь в виде значения внутри другого словаря либо внутри списка
или кортежа.
"""
#Пустой словарь
my_dict = {}
#Двухэлементный словарь
my_dict = {'name': 'Alex', 'course': 3}
#Вложение
my_dict = {'info': {'name': 'Alex', 'course': 3}}
print(my_dict)

my_dict = dict(name='Alex', course=3)
my_dict = dict([('name','Alex'), ('course',3)])
print(my_dict)

keylist = ['name', 'course', 'age']
valuelist = ['Alex', 3, 20]
my_dict = dict(zip(keylist,valuelist)) #{'name': 'Alex', 'course': 3, 'age': 20} # zip создает пары (ключ, значение)
print(my_dict)
my_dict = dict.fromkeys(['name','course'])
print(my_dict)

#Добавление элементов в словарь

my_dict = {}
my_dict['name'] = 'Alex'
my_dict['course'] = 3
my_dict['age'] = '41'
my_dict['gender'] = 'Female'
print(my_dict)
print(my_dict['name']) #Вывод значения по ключу

#при обращении к значению элемента по его ключу стоит быть осторожным, так как элемент может отсутствовать в словаре

#print(my_dict['info']) #    print(my_dict['info'])~~~~~~~^^^^^^^^ KeyError: 'info'

#Перед таким обращением нужно проверить существует ли запись с данным ключом в словаре:
print('info' in my_dict)  #False
print('name' in my_dict)  #True

#Обойти проблему проверки можно используя метод setdefault(key, def_val)

print(my_dict.get('name', 'Maxim'))
#Alex пытается получить значение по ключу 'name' из словаря, и если такого ключа нет - возвращает значение по умолчанию 'Maxim'.
print(my_dict.get('info', 'no')) #no

"""Бывают моменты, когда необходимо получить список:
 - ключей,
 - значений 
 - или кортеж пар "ключ:значение" словаря
   для этого используются следующие методы: 
"""

my_dict = {'name': 'Alex', 'course': 3, 'info':{'age':21, 'country': 'rus'}}

#Вывести все ключи
print(list(my_dict.keys())) # ['name', 'course', 'info']

#Вывести все значения
print(list(my_dict.values())) # ['Alex', 3, {'age': 21, 'country': 'rus'}]

#Кортежи пар ключ-значение
print(list(my_dict.items())) # [('name', 'Alex'), ('course', 3), ('info', {'age': 21, 'country': 'rus'})]

#Копировать словарь можно следующим способом:
my_dict = {'name': 'Alex', 'course': 3}
my_new_dict = my_dict.copy()
my_new_dict['info'] = 'None'
print(my_dict) #{'name': 'Alex', 'course': 3}
print(my_new_dict) #{'name': 'Alex', 'course': 3, 'info': 'None'}

"""Приведенным выше способом осуществляется поверхностное копирование, а это значит, что при наличии
в виде значения у словаря списка, вложенного словаря или измененных типов будут скопированы ссылки на эти объекты
Таким образом при их изменении изменяться объекты и в исходном словаре:
"""

my_dict = {'name': 'Alex', 'course': 3, 'info':{'age':21, 'country': 'rus'}}
print(my_dict) #{'name': 'Alex', 'course': 3, 'info': {'age': 21, 'country': 'rus'}}
my_new_dict = my_dict.copy()
my_new_dict['info']['age'] = 1
print(my_new_dict)
print(my_dict) # {'name': 'Alex', 'course': 3, 'info': {'age': 1, 'country': 'rus'}} вместо   {'name': 'Alex', 'course': 3, 'info':{'age':21, 'country': 'rus'}}

"""Чтобы избежать такой проблемы, следует использовать глубокое копирование"""

import copy
my_dict = {'name': 'Alex', 'course': 3, 'info':{'age':21, 'country': 'rus'}}
my_new_dict = copy.deepcopy(my_dict)
my_new_dict['info']['age'] = 1
print(my_new_dict)
print(my_dict) # {'name': 'Alex', 'course': 3, 'info': {'age': 21, 'country': 'rus'}}

"""Удаление или извлечение пар ключ:значение в словаре осуществляется следующими способами: 
"""

my_dict = {'name': 'Alex', 'course': 3, 'test1':10, 'test2':'prob', 'test3': 3.56}
print(my_dict) #{'name': 'Alex', 'course': 3, 'test1': 10, 'test2': 'prob', 'test3': 3.56}

print(my_dict.pop('test3', 10)) #3.56 Если ключа нет - возвращает значение по умолчанию (второй аргумент)
print(my_dict) #{'name': 'Alex', 'course': 3, 'test1': 10, 'test2': 'prob'}

print(my_dict.popitem()) #Возвращение удаленных значение ('test2', 'prob')
del my_dict['name'] # Удаление элементов по ключу
print(my_dict) #{'course': 3, 'test1': 10}

"""Для добавления двух словарей по ключам используется следующий подход
"""

my_dict = {'name':'Alex', 'course': 3}
my_new_dict = {'test1':10, 'test2':'prob', 'test3': 3.56}
my_dict.update(my_new_dict)
print(my_dict) #{'name': 'Alex', 'course': 3, 'test1': 10, 'test2': 'prob', 'test3': 3.56}

"""Бывают случаи когда ключи в одном и другом словаре совпадают, тогда произойдет замена
значений по ключам у того словаря, которому вы вызываете метод update"""

my_dict = {'name':'Alex', 'course': 3}
my_new_dict = {'test1':10, 'name':'prob', 'test3': 3.56}
my_dict.update(my_new_dict)
print(my_dict) #{'name': 'prob', 'course': 3, 'test1': 10, 'test3': 3.56}

"""Основные операторы в Python:
каждый оператор имеет собственное специфическое значение и собственный специфический синтаксис - правила,
определяющие его структуру
Операторы классифицируются следующим образом:

- процедурные операторы
- операторы классов
- операторы исключений
- операторы модулей
- арифметические операторы
- операторы сравнения
- операторы присваивания
- побитовые операторы
- логические операторы
- операторы членства

"""


"""Управляющие конструкции

if в Python выбирает действия, которые будут выполняться в процессе работы программы в зависимости
от условий.
Он является основным инструментом выбора в Python и представляет большой объем логики.
Самая общая форма конструкции if then else в Python выглядит так:
if условие1:
     блок1
elif условие2:
     блок2
...
elif условие(n-1):
     блок(n-1):
else: 
     блок(n)
     
Если результат условия проверки условия1 равен True, то выполняется блок1 и так далее.
Если ни одно условие не выполнилось и все проверки вернули False, то выполняется блок в else.
Если блока else нет и при этом все проверки вернули False, то ни один из блоков ветвления 
не выполнится. 
Блок else является необязательным и может быть опущен

Рассмотрим пример ветвления
Если температура на улице > 30 градусов по цельсию то надеть шоорты, иначе одеть брюки
"""

t=20
if t > 30:
    print('Надеть шорты')
else:
    print('Надеть брюки')

#Взять зонт
#Выйти на улицу
sun=False
if not sun:
    print("Взять зонт")
print('Выйти на улицу')


""""Следующим примером разберем как посредством условной конструкции
можно проверить входит ли значение в определенный диапазон или нет"""

value = 1445
if 0 < value < 10:
    print('Число входит в диапазон от 0 до 10')
elif 10 < value < 20:
    print('Число входит в диапазон от 10 до 20')
elif 20 < value < 30:
    print('Число входит в диапазон от 20 до 30')
else:
    print('Значение больше 30')

"""Условные конструкции могут иметь различную степень вложенности"""
value = 9000
if value > 30:
    if value < 50:
        print('30 < value < 50')
    else:
        print('30 < value >= 50')
else:
    if value > 10:
        print('30 >= value > 10')
    else:
        print('30 >= value < 10')

"""Когда необходимо указать что в данном блоке ничего не выполняется, то используется команда pass, которая
размещается там, где должна находиться команда, но никаких действий она не выполняет"""
a = 26
if a < 25:
    pass
else:
   print(a)

"""Оператор match
Если блок кода в программе состоит из большого числа цепочек if elif else стоит задуматься об использовании
другой условной конструкции управления потоком выполнения программы: match-case
Ее синтаксис достаточно прост в использовании и позволяет сократить объем кода посредством замены
блоков if, осуществляющих сравнение переменных встроенных типов данных, последовательностей, экземпляров классов
с помощью оператора ==.

match выражение:
    case шаблон1:
         блок1
    case шаблон2:
         блок2
    case _:
         блок(n) #действие по умолчанию
         
На вход оператора match подается выражение, которое должно возвращать значение или непосредственно само значение, с
которым будут осуществляться проверки в блоках case.
Если значением совпадает с одним из имеющихся шаблонов в блоках case, то выполнится конкретный блок кода и программа продолжит 
свою работу со строчки, следующей за конструкцией match case. В противном случае выполнится необязательный блок
case _ (может отсуствовать)

"""

value = 4
match value:
    case 2:
        print('2')
        print(f'{value} + 2 = {value + 2}')
    case 4:
        print('4')
        print(f'{value} + 4 = {value + 4}')
    case _:
        print('8')

"""При использовании инструкции match case желательно, чтобы подаваемые на вход оператора  match и сравниваемые
 значения были одного и того же типа. Дополнительно, в конструкции  match  - case можно использовать моржовый
 оператор :=  тем самым объявить и инициализировать переменную"""

value = 0
match value2 := value + 2:
    case 2:
         print(f'{value} + 2 = {value + 2}')
    case 4:
        print('4')
    case _:
        print('8')
print(f'value = {value}')
print(f'value = {value2}')

""" Если по нескольким значениям необходимо выполнить один и тот же код, то можно прибегнуть к следующему формату использования 
рассматриваемой условной конструкции """

name = 'Stanislav'
match name:
    case 'Stanislav':
        print('Admin')
    case 'Maxim' | 'Alex' | 'Bill':
        print('Employee')
    case _:
        print('Oo')

"""Так как  match  осуществляет сопоставление шаблонов, то его можно использовать с кортежами и словарями"""

#С кортежем

animal = ('Alex', 'cat', 10)
match animal:
    case ('Tom', 'dog', 14):
        print('Dog')
    case ('Alex', 'cat', 10): # Cat
        print('Cat')

#Если необходимо, чтобы какой-то элемент кортежа соответствовал некоторому набору значений - необходимо перечислить
# их через вертикальную черту

animal = ('Alex', 'dog', 10)
match animal:
    case ('Tom' | 'Alex', 'dog', 14 | 10):
        print('Dog') #Dog
    case ('Alex', 'cat', 10):
        print('Cat')

